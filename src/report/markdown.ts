/**
 * Markdown report generator
 * Generates a clean, readable impact report in Markdown format
 */

import type { ImpactReport, ProjectSummary, Feature } from '../domain/models';

/**
 * Format a date string to a more readable format
 */
function formatDate(dateStr: string): string {
  const date = new Date(dateStr);
  return date.toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
  });
}

/**
 * Format a date range
 */
function formatDateRange(startDate: string, endDate: string): string {
  const start = formatDate(startDate);
  const end = formatDate(endDate);

  if (start === end) {
    return start;
  }

  return `${start} â€“ ${end}`;
}

/**
 * Capitalize first letter
 */
function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Format PR numbers as links (if repo URL is known) or plain numbers
 */
function formatPRNumbers(prs: number[], repoFullName?: string): string {
  if (repoFullName) {
    return prs
      .map((pr) => `[#${pr}](https://github.com/${repoFullName}/pull/${pr})`)
      .join(', ');
  }
  return prs.map((pr) => `#${pr}`).join(', ');
}

/**
 * Generate markdown for a single feature
 */
function generateFeatureMarkdown(feature: Feature, repoFullName: string): string {
  const lines: string[] = [];

  lines.push(`- **${feature.title}**`);
  lines.push(`  - ${feature.description}`);
  lines.push(`  - PRs: ${formatPRNumbers(feature.prs, repoFullName)}`);
  lines.push(`  - Type: ${capitalize(feature.type)}`);
  lines.push(`  - Confidence: ${capitalize(feature.confidence)}`);

  return lines.join('\n');
}

/**
 * Generate markdown for a project summary
 */
function generateProjectMarkdown(summary: ProjectSummary): string {
  const lines: string[] = [];

  lines.push(`## Project: ${summary.repoFullName}`);
  lines.push('');
  lines.push(`**Duration:** ${formatDateRange(summary.startDate, summary.endDate)}`);
  lines.push('');
  lines.push(`**Total PRs:** ${summary.totalPRs}`);
  lines.push('');
  lines.push('### Shipped Features');
  lines.push('');

  for (const feature of summary.features) {
    lines.push(generateFeatureMarkdown(feature, summary.repoFullName));
    lines.push('');
  }

  return lines.join('\n');
}

/**
 * Generate the full impact report in Markdown format
 */
export function generateMarkdownReport(report: ImpactReport): string {
  const lines: string[] = [];

  // Header
  lines.push('# Engineering Impact Report');
  lines.push('');

  // Report metadata
  lines.push(`**Author:** ${report.username}`);
  lines.push(`**Period:** ${formatDateRange(report.since, report.until)}`);
  lines.push(`**Generated:** ${formatDate(report.generatedAt)}`);
  lines.push('');

  // Summary statistics
  lines.push('---');
  lines.push('');
  lines.push('## Summary');
  lines.push('');
  lines.push(`- **Total Projects:** ${report.projects.length}`);
  lines.push(`- **Total PRs Merged:** ${report.totalPRs}`);
  lines.push(`- **Total Features Shipped:** ${report.totalFeatures}`);
  lines.push('');

  // Feature breakdown by type
  const typeBreakdown = getTypeBreakdown(report);
  if (Object.keys(typeBreakdown).length > 0) {
    lines.push('### Feature Breakdown');
    lines.push('');
    for (const [type, count] of Object.entries(typeBreakdown)) {
      lines.push(`- ${capitalize(type)}: ${count}`);
    }
    lines.push('');
  }

  lines.push('---');
  lines.push('');

  // Project sections
  for (const project of report.projects) {
    lines.push(generateProjectMarkdown(project));
    lines.push('---');
    lines.push('');
  }

  // Footer
  lines.push('*Report generated by whatidid*');

  return lines.join('\n');
}

/**
 * Get feature count breakdown by type
 */
function getTypeBreakdown(report: ImpactReport): Record<string, number> {
  const breakdown: Record<string, number> = {};

  for (const project of report.projects) {
    for (const feature of project.features) {
      breakdown[feature.type] = (breakdown[feature.type] ?? 0) + 1;
    }
  }

  // Sort by count (descending)
  const sorted = Object.entries(breakdown)
    .sort(([, a], [, b]) => b - a)
    .reduce(
      (acc, [key, value]) => {
        acc[key] = value;
        return acc;
      },
      {} as Record<string, number>
    );

  return sorted;
}

/**
 * Write the report to a file
 */
export async function writeReport(
  report: ImpactReport,
  outputPath: string
): Promise<void> {
  const markdown = generateMarkdownReport(report);
  await Bun.write(outputPath, markdown);
}
